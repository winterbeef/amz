#!/usr/bin/env python3

import heapq

def dijkstra(graph, start_node):
    # total distance from start to node; distance from start is 0
    distances = {node: float('inf') for node in graph}
    distances[start_node] = 0

    # this is updated as the node "upstream" on the shortest current path
    predecessors = {node: None for node in graph}

    
    priority_queue = [(0, start_node)]  # (distance, node)

    while priority_queue:
        current_distance, current_node = heapq.heappop(priority_queue)

        # If we found a shorter path to current_node already, skip
        if current_distance > distances[current_node]:
            continue

        for neighbor, weight in graph[current_node].items():
            distance = current_distance + weight

            if distance < distances[neighbor]:
                distances[neighbor] = distance
                predecessors[neighbor] = current_node
                heapq.heappush(priority_queue, (distance, neighbor))

    return distances, predecessors

def reconstruct_path(predecessors, start_node, end_node):
    """
    Reconstructs the shortest path from start_node to end_node using predecessors.

    Args:
        predecessors (dict): Dictionary of predecessors generated by dijkstra().
        start_node: The starting node.
        end_node: The destination node.

    Returns:
        list: A list representing the shortest path from start_node to end_node.
              Returns an empty list if no path exists.
    """
    path = []
    current = end_node
    while current is not None:
        path.insert(0, current)
        current = predecessors[current]
        if current == start_node:  # Stop if we reached the start node
            path.insert(0, start_node)
            break
        if current is None and end_node not in path: # Handle disconnected graphs
            return []
    return path if path[0] == start_node else [] # Ensure path starts correctly


# Example Usage:
if __name__ == "__main__":
    graph = {
        'A': {'B': 1, 'C': 4},
        'B': {'A': 1, 'C': 2, 'D': 5},
        'C': {'A': 4, 'B': 2, 'D': 1},
        'D': {'B': 5, 'C': 1}
    }

    start = 'A'
    distances, predecessors = dijkstra(graph, start)

    print(f"Shortest distances from {start}: {distances}")
    # Expected: {'A': 0, 'B': 1, 'C': 3, 'D': 4}

    end = 'D'
    path = reconstruct_path(predecessors, start, end)
    print(f"Shortest path from {start} to {end}: {path}")
    # Expected: ['A', 'B', 'C', 'D']

